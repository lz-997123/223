<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ¨¡å‹æŸ¥çœ‹å™¨</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%);
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 23, 42, 0.95);
            color: #e2e8f0;
            padding: 24px 32px;
            border-radius: 16px;
            text-align: center;
            z-index: 100;
            border: 1px solid #334155;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            min-width: 260px;
            transition: opacity 0.3s ease;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(59, 130, 246, 0.3);
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(15, 23, 42, 0.9);
            color: #e2e8f0;
            padding: 16px;
            border-radius: 12px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            line-height: 1.5;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            max-width: 280px;
        }
        .controls-header {
            color: #60a5fa;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-item {
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: #cbd5e1;
        }
        .icon {
            width: 16px;
            text-align: center;
            color: #60a5fa;
        }
        .btn {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 10px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(59, 130, 246, 0.3);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn-secondary {
            background: rgba(51, 65, 85, 0.8);
            margin-top: 8px;
        }
        .slider-container {
            margin: 15px 0;
            padding: 12px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
            color: #94a3b8;
        }
        input[type="range"] {
            width: 100%;
            height: 4px;
            background: rgba(100, 116, 139, 0.3);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #60a5fa;
            transform: scale(1.1);
        }
        #mobile-warning {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(234, 179, 8, 0.9);
            color: #78350f;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 12px;
            display: none;
            z-index: 50;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(234, 179, 8, 0.3);
        }
        @media (max-width: 768px) {
            #controls {
                left: 50%;
                transform: translateX(-50%);
                bottom: 10px;
                width: 90%;
                max-width: 400px;
            }
            #mobile-warning {
                display: block;
                top: 10px;
                width: 90%;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="mobile-warning">
        ğŸ“± ç§»åŠ¨è®¾å¤‡ï¼šåŒæŒ‡ç¼©æ”¾/æ—‹è½¬ï¼Œå•æŒ‡æ‹–æ‹½æŸ¥çœ‹
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div style="font-size: 16px; margin-bottom: 8px; color: #f8fafc;">ğŸš€ åŠ è½½æ¨¡å‹ä¸­...</div>
        <div id="progress" style="font-size: 14px; color: #60a5fa; margin-bottom: 12px;">0%</div>
        <div style="font-size: 11px; color: #94a3b8;">æ¨¡å‹è¾ƒå¤§æ—¶å¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´</div>
        <div id="loading-details" style="font-size: 10px; color: #64748b; margin-top: 8px;"></div>
    </div>

    <div id="controls">
        <div class="controls-header">
            <span>ğŸ® æ§åˆ¶é¢æ¿</span>
        </div>

        <div class="control-item">
            <span class="icon">ğŸ‘†</span>
            <span>å•æŒ‡æ‹–æ‹½ï¼šæ—‹è½¬è§†è§’</span>
        </div>
        <div class="control-item">
            <span class="icon">âœŒï¸</span>
            <span>åŒæŒ‡ç¼©æ”¾/æ—‹è½¬</span>
        </div>
        <div class="control-item">
            <span class="icon">ğŸ‘†</span>
            <span>åŒæŒ‡æ‹–æ‹½ï¼šå¹³ç§»è§†å›¾</span>
        </div>

        <div class="slider-container">
            <div class="slider-label">
                <span>æ¨¡å‹ç¼©æ”¾:</span>
                <span id="zoom-value">1.0x</span>
            </div>
            <input type="range" id="zoom-slider" min="0.001" max="1" step="0.001" value="0.001">
        </div>

        <button class="btn" onclick="toggleAutoRotate()">
            <span id="rotate-icon">ğŸ”„</span>
            è‡ªåŠ¨æ—‹è½¬: <span id="rotate-status">å…³</span>
        </button>
        <button class="btn btn-secondary" onclick="resetView()">
            <span>ğŸ¯</span>
            é‡ç½®è§†è§’
        </button>
        <button class="btn btn-secondary" onclick="toggleGrid()">
            <span>#ï¸âƒ£</span>
            æ˜¾ç¤ºç½‘æ ¼: <span id="grid-status">å…³</span>
        </button>
    </div>

    <!-- Three.js åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, controls, model;
        let container = document.getElementById('canvas-container');
        let loading = document.getElementById('loading');
        let progress = document.getElementById('progress');
        let loadingDetails = document.getElementById('loading-details');
        let zoomSlider = document.getElementById('zoom-slider');
        let zoomValue = document.getElementById('zoom-value');
        let autoRotate = false;
        let rotateStatus = document.getElementById('rotate-status');
        let rotateIcon = document.getElementById('rotate-icon');
        let gridStatus = document.getElementById('grid-status');
        let gridVisible = false;
        let gridHelper;

        // æ£€æµ‹ç§»åŠ¨è®¾å¤‡
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

        // åˆå§‹åŒ–åœºæ™¯
        function init() {
            // 1. åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);

            // æ·»åŠ ç¯å¢ƒå…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));

            // 2. åˆ›å»ºç›¸æœº - ä½¿ç”¨æ›´å¤§çš„è§†é‡è§’åº¦
            camera = new THREE.PerspectiveCamera(
                75, // æ›´å¤§çš„è§†é‡è§’åº¦
                window.innerWidth / window.innerHeight,
                0.1, // å®‰å…¨çš„è¿‘è£å‰ªå¹³é¢
                100000 // æ›´å¤§çš„è¿œè£å‰ªå¹³é¢
            );

            // åˆå§‹ç›¸æœºä½ç½® - è®¾ç½®å¾—æ›´è¿œ
            camera.position.set(0, 0, 10000);

            // 3. åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: "high-performance",
                precision: 'highp'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputEncoding = THREE.sRGBEncoding;

            container.appendChild(renderer.domElement);

            // 4. æ·»åŠ å…‰æº
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(10000, 20000, 10000);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight2.position.set(-10000, 10000, -10000);
            scene.add(directionalLight2);

            // 5. æ·»åŠ è½¨é“æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // ä¸ºå¤§å‹æ¨¡å‹è®¾ç½®æ›´å¤§çš„èŒƒå›´
            controls.minDistance = 1;
            controls.maxDistance = 50000; // æ›´å¤§çš„æœ€å¤§è·ç¦»
            controls.maxPolarAngle = Math.PI;

            // ç§»åŠ¨è®¾å¤‡ä¼˜åŒ–
            if (isMobile) {
                controls.enableZoom = true;
                controls.enablePan = true;
                controls.enableRotate = true;
                controls.touches = {
                    ONE: THREE.TOUCH.ROTATE,
                    TWO: THREE.TOUCH.DOLLY_PAN
                };
                controls.rotateSpeed = 0.5;
                controls.panSpeed = 1;
                controls.zoomSpeed = 0.5;
            }

            controls.target.set(0, 0, 0);
            controls.update();

            // åŒå‡»èšç„¦æ¨¡å‹
            renderer.domElement.addEventListener('dblclick', focusOnModel);

            // 6. æ·»åŠ ç½‘æ ¼åœ°é¢ - ä½¿ç”¨æ›´å¤§çš„ç½‘æ ¼
            addGrid();

            // 7. ç¼©æ”¾æ§åˆ¶
            zoomSlider.addEventListener('input', function() {
                const value = parseFloat(this.value);
                zoomValue.textContent = value.toFixed(3) + 'x';
                if (model) {
                    model.scale.set(value, value, value);
                }
            });

            // 8. å¤„ç†çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', onWindowResize);

            // 9. å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();

            // 10. åŠ è½½æ¨¡å‹
            setTimeout(loadModel, 100);
        }

        // æ·»åŠ ç½‘æ ¼åœ°é¢ - ä¸ºå¤§å‹æ¨¡å‹ä½¿ç”¨æ›´å¤§çš„ç½‘æ ¼
        function addGrid() {
            gridHelper = new THREE.GridHelper(100000, 100, 0x444444, 0x222222);
            gridHelper.visible = gridVisible;
            scene.add(gridHelper);
        }

        // åˆ‡æ¢ç½‘æ ¼æ˜¾ç¤º
        function toggleGrid() {
            gridVisible = !gridVisible;
            gridHelper.visible = gridVisible;
            gridStatus.textContent = gridVisible ? 'å¼€' : 'å…³';
            gridStatus.style.color = gridVisible ? '#10b981' : '#ffffff';
        }

        // åŠ è½½æ¨¡å‹å‡½æ•°
        function loadModel() {
            if (typeof THREE.GLTFLoader === 'undefined') {
                loading.innerHTML = `
                    <div style="color: #ef4444; font-size: 16px; margin-bottom: 10px;">âŒ åŠ è½½å¤±è´¥</div>
                    <div style="margin-top: 10px; font-size: 12px;">Three.js åº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•</div>
                    <button class="btn" onclick="location.reload()" style="margin-top: 15px;">åˆ·æ–°é¡µé¢</button>
                `;
                return;
            }

            const loader = new THREE.GLTFLoader();
            const modelPath = '1.glb';

            console.log('æ­£åœ¨åŠ è½½æ¨¡å‹:', modelPath);
            loadingDetails.textContent = 'æ­£åœ¨åˆå§‹åŒ–åŠ è½½å™¨...';

            loader.load(
                modelPath,
                function(gltf) {
                    console.log('âœ… æ¨¡å‹åŠ è½½æˆåŠŸ');
                    model = gltf.scene;

                    // éå†æ¨¡å‹æ‰€æœ‰æè´¨
                    model.traverse(function(child) {
                        if (child.isMesh) {
                            child.frustumCulled = false; // é˜²æ­¢è§†é”¥ä½“å‰”é™¤

                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => optimizeMaterial(mat));
                                } else {
                                    optimizeMaterial(child.material);
                                }
                            }
                        }
                    });

                    // å°†æ¨¡å‹æ”¾åœ¨åŸç‚¹
                    model.position.set(0, 0, 0);

                    // è®¡ç®—æ¨¡å‹è¾¹ç•Œ
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);

                    console.log('æ¨¡å‹åŸå§‹å°ºå¯¸:', size);
                    console.log('æœ€å¤§ç»´åº¦:', maxDim);
                    console.log('æ¨¡å‹ä¸­å¿ƒ:', center);

                    // å…³é”®ï¼šå¯¹äºå¤§å‹æ¨¡å‹ï¼Œä½¿ç”¨æ›´å°çš„ç¼©æ”¾æ¯”ä¾‹
                    let scale = 1;
                    if (maxDim > 0) {
                        if (maxDim > 10000) {
                            // è¶…å¤§å‹æ¨¡å‹ï¼šå¤§å¹…ç¼©å°
                            scale = 100 / maxDim; // å°†æ¨¡å‹ç¼©å°åˆ°100å•ä½ä»¥å†…
                        } else if (maxDim > 1000) {
                            scale = 500 / maxDim; // å°†æ¨¡å‹ç¼©å°åˆ°500å•ä½ä»¥å†…
                        } else if (maxDim > 100) {
                            scale = 50 / maxDim; // å°†æ¨¡å‹ç¼©å°åˆ°50å•ä½ä»¥å†…
                        } else if (maxDim < 0.1) {
                            scale = 10 / maxDim; // æ”¾å¤§å°æ¨¡å‹
                        } else {
                            scale = 10 / maxDim; // é»˜è®¤ç¼©æ”¾
                        }

                        // ç¡®ä¿ç¼©æ”¾èŒƒå›´åˆç†
                        scale = Math.max(0.0001, Math.min(100, scale));

                        model.scale.setScalar(scale);
                        console.log('åº”ç”¨ç¼©æ”¾:', scale);
                    }

                    // é‡æ–°è®¡ç®—ç¼©æ”¾åçš„è¾¹ç•Œ
                    const scaledBox = new THREE.Box3().setFromObject(model);
                    const scaledSize = scaledBox.getSize(new THREE.Vector3());
                    const scaledMaxDim = Math.max(scaledSize.x, scaledSize.y, scaledSize.z);
                    const scaledCenter = scaledBox.getCenter(new THREE.Vector3());

                    console.log('ç¼©æ”¾åå°ºå¯¸:', scaledSize);
                    console.log('ç¼©æ”¾åæœ€å¤§ç»´åº¦:', scaledMaxDim);
                    console.log('ç¼©æ”¾åä¸­å¿ƒ:', scaledCenter);

                    // æ›´æ–°UIç¼©æ”¾æ˜¾ç¤º
                    zoomSlider.value = scale;
                    zoomValue.textContent = scale.toFixed(4) + 'x';

                    // æ·»åŠ åˆ°åœºæ™¯
                    scene.add(model);

                    // å…³é”®ï¼šè®¾ç½®ç›¸æœºä½ç½® - æ ¹æ®ç¼©æ”¾åçš„æ¨¡å‹å°ºå¯¸
                    if (scaledMaxDim > 0) {
                        // è®¡ç®—ç›¸æœºè·ç¦»ï¼šè®©æ¨¡å‹å æ»¡è§†é‡
                        const distance = scaledMaxDim * 1.5; // 1.5å€è·ç¦»

                        // è®¾ç½®ç›¸æœºåœ¨æ¨¡å‹çš„å‰ä¸Šæ–¹
                        camera.position.set(
                            scaledCenter.x + distance,
                            scaledCenter.y + distance * 0.5,
                            scaledCenter.z + distance
                        );

                        console.log('ç›¸æœºä½ç½®:', camera.position);
                        console.log('ç›¸æœºè·ç¦»æ¨¡å‹ä¸­å¿ƒ:', camera.position.distanceTo(scaledCenter));
                    } else {
                        // å¦‚æœæ— æ³•è®¡ç®—å°ºå¯¸ï¼Œä½¿ç”¨é¢„è®¾çš„è·ç¦»
                        camera.position.set(0, 0, 1000);
                    }

                    camera.lookAt(scaledCenter);
                    controls.target.set(scaledCenter.x, scaledCenter.y, scaledCenter.z);

                    // æ›´æ–°æ§åˆ¶å™¨é™åˆ¶
                    controls.minDistance = scaledMaxDim * 0.1;
                    controls.maxDistance = scaledMaxDim * 50;
                    controls.update();

                    // æ˜¾ç¤ºåŠ è½½å®Œæˆ
                    loadingDetails.textContent = `æ¨¡å‹å°ºå¯¸: ${size.x.toFixed(2)} Ã— ${size.y.toFixed(2)} Ã— ${size.z.toFixed(2)}`;

                    // éšè—åŠ è½½æç¤º
                    setTimeout(() => {
                        loading.style.opacity = '0';
                        setTimeout(() => {
                            loading.style.display = 'none';
                        }, 300);

                        // è‡ªåŠ¨ç¼©æ”¾æ»‘å—åˆ°åˆé€‚ä½ç½®
                        zoomSlider.value = scale;
                        zoomValue.textContent = scale.toFixed(4) + 'x';

                        // å¦‚æœæ²¡æœ‰çœ‹åˆ°æ¨¡å‹ï¼Œæç¤ºç”¨æˆ·
                        setTimeout(() => {
                            if (!isModelVisible()) {
                                console.log('æ¨¡å‹å¯èƒ½ä¸å¯è§ï¼Œå°è¯•é‡ç½®è§†è§’');
                                resetView();
                            }
                        }, 1000);
                    }, 800);

                    console.log('âœ… æ¨¡å‹åŠ è½½å®Œæˆ');
                },
                function(xhr) {
                    const percent = Math.floor((xhr.loaded / xhr.total) * 100);
                    progress.textContent = percent + '%';

                    if (xhr.total > 0) {
                        const loadedMB = (xhr.loaded / (1024 * 1024)).toFixed(1);
                        const totalMB = (xhr.total / (1024 * 1024)).toFixed(1);
                        loadingDetails.textContent = `å·²åŠ è½½ ${loadedMB}MB / ${totalMB}MB`;
                    }

                    if (percent === 100) {
                        progress.textContent = '100% âœ“';
                        progress.style.color = '#10b981';
                        loadingDetails.textContent = 'æ­£åœ¨å¤„ç†æ¨¡å‹æ•°æ®...';
                    }
                },
                function(error) {
                    console.error('âŒ æ¨¡å‹åŠ è½½é”™è¯¯:', error);
                    loading.innerHTML = `
                        <div style="color: #ef4444; font-size: 16px; margin-bottom: 10px;">âŒ åŠ è½½å¤±è´¥</div>
                        <div style="margin-top: 10px; font-size: 12px;">${
                            error.message || 'è¯·æ£€æŸ¥æ¨¡å‹æ–‡ä»¶è·¯å¾„å’Œæ ¼å¼'
                        }</div>
                        <div style="margin-top: 10px; font-size: 11px; color: #94a3b8;">æ”¯æŒæ ¼å¼: .glb, .gltf</div>
                        <button class="btn" onclick="location.reload()" style="margin-top: 15px;">é‡æ–°åŠ è½½</button>
                        <button class="btn btn-secondary" onclick="loadModel()" style="margin-top: 10px;">é‡è¯•åŠ è½½</button>
                    `;
                }
            );
        }

        // æ£€æŸ¥æ¨¡å‹æ˜¯å¦å¯è§
        function isModelVisible() {
            if (!model || !camera) return false;

            const box = new THREE.Box3().setFromObject(model);
            const frustum = new THREE.Frustum();
            frustum.setFromProjectionMatrix(
                new THREE.Matrix4().multiplyMatrices(
                    camera.projectionMatrix,
                    camera.matrixWorldInverse
                )
            );

            return frustum.intersectsBox(box);
        }

        // ä¼˜åŒ–æè´¨
        function optimizeMaterial(material) {
            if (!material) return;

            material.precision = 'highp';
            material.depthWrite = true;
            material.depthTest = true;
            material.transparent = false;
            material.opacity = 1.0;
            material.side = THREE.FrontSide;
        }

        // èšç„¦æ¨¡å‹
        function focusOnModel() {
            if (!model) return;

            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);

            // è®¾ç½®ç›¸æœºè·ç¦»
            const distance = maxDim * 1.2;

            camera.position.set(
                center.x + distance,
                center.y + distance * 0.5,
                center.z + distance
            );

            camera.lookAt(center.x, center.y, center.z);
            controls.target.set(center.x, center.y, center.z);
            controls.update();
        }

        // é‡ç½®è§†è§’
        function resetView() {
            if (!model) {
                camera.position.set(0, 0, 1000);
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
            } else {
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);

                // è®¡ç®—åˆé€‚çš„è·ç¦»
                const distance = Math.max(100, maxDim * 1.5);

                camera.position.set(
                    center.x + distance,
                    center.y + distance * 0.3,
                    center.z + distance
                );

                camera.lookAt(center);
                controls.target.set(center.x, center.y, center.z);
            }
            controls.update();
        }

        // åˆ‡æ¢è‡ªåŠ¨æ—‹è½¬
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            rotateStatus.textContent = autoRotate ? 'å¼€' : 'å…³';
            rotateStatus.style.color = autoRotate ? '#10b981' : '#ffffff';
            rotateIcon.textContent = autoRotate ? 'â¸ï¸' : 'ğŸ”„';
            rotateIcon.style.animation = autoRotate ? 'spin 2s linear infinite' : 'none';
        }

        // çª—å£å¤§å°å˜åŒ–å¤„ç†
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            // æ›´æ–°æ§åˆ¶å™¨
            if (controls) {
                controls.update();
            }

            // è‡ªåŠ¨æ—‹è½¬
            if (model && autoRotate) {
                model.rotation.y += 0.005;
            }

            renderer.render(scene, camera);
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', init);

        // é˜²æ­¢è§¦æ‘¸äº‹ä»¶æ»šåŠ¨é¡µé¢
        document.addEventListener('touchmove', function(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>